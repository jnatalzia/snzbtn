<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Leap Motion JavaScript Sample</title>
<script src="http://js.leapmotion.com/0.2.0/leap.min.js"></script>
<script src="jquery.js"></script>
<!--//load classes-->
<script src="utilities/helper.js"></script>
<script src="classes/VariableBlock.js"></script>
<script src="classes/SpriteNode.js"></script>
<script src="classes/DragSpot.js"></script>
<script src="classes/Cutscene.js"></script>
<script src="classes/Hand.js"></script>
<script src="classes/LevelOne.js"></script>
<script>
	var debug = true;

	var previousFrame = null;
	var paused = false;
	var pauseOnGesture = false;
	var browserWidth,browserHeight;
	var circdi=20;
	
	var currIDs = [],prevIDs = [];

	var canvas, ctx;

	var startDragY = -1;

	var dragCircle; // Here ------------- maybe change to dragSquare

	var STATE_TOOLBOX_OPEN = 0,STATE_TOOLBOX_CLOSED= 1,STATE_TOOLBOX_CLOSING = 2;
	var gameState = 1;

	var STATE_CAN_PINCH = false;
	var STATE_PINCH = false;
	var STATE_CAN_ZOOM = false;
	var STATE_ZOOM = false;
	var currentMag = 100;

	var toolboxIMG = new Image(),toolBox;
	toolboxIMG.src = "img/wires/toolBox/closed.png";

	var buildBar = new Image();
	buildBar.src = "img/wires/buildBar.png";

	var runBtnActive = new Image();
	runBtnActive.src = "img/wires/runBTN_active.png";

	var runBtnInactive = new Image();
	runBtnInactive.src = "img/wires/runBTN_inactive.png";

	var exitBtn = new Image();
	exitBtn.src = "img/wires/exitBTN.png";

	var arrowIcon = new Image();
	arrowIcon.src = "img/wires/arrow.png";


	var floatingBlocks = [];
	var tempBlock, tempSprite, tempCutscene, tempHand;

	var globalFrame;

	var STATE_CAN_DRAG = false;
	var STATE_DRAG;

	//Level Vars
	var currLevelNum = 1,currLevel;

	window.onload = function()
	{
		browserWidth = window.innerWidth;
		browserHeight = window.innerHeight;

		canvas = document.getElementById("canvas");
		ctx = canvas.getContext("2d");
		ctx.canvas.width  = window.innerWidth;
  		ctx.canvas.height = window.innerHeight;
  		//Here ------------------------------ Change this things 
  		dragCircle = {};
  		dragCircle.x = browserWidth/10 - 5;
  		dragCircle.y = browserHeight - 100;
  		dragCircle.radius = 50;


  		tempHand = new Hand();

  		//load all levels
  		currLevel = new LevelOne();

  		console.log(currLevel);

  		update();
	};
	window.onresize = function()
	{
		browserWidth = window.innerWidth;
		browserHeight = window.innerHeight;

		ctx.canvas.width  = window.innerWidth;
  		ctx.canvas.height = window.innerHeight;
	}
	// Setup Leap loop with frame callback function
	var controllerOptions = {enableGestures: true};
	
	Leap.loop(controllerOptions, function(f) {
		//console.log(f);
		globalFrame = f;
	});
	function update()
	{
		if (globalFrame)
		{

			ctx.clearRect(0,0,browserWidth,browserHeight);
			//commented to test varible block code
			//tempBlock.blockHoverTest(globalFrame,ctx);
			currLevel.update(ctx,globalFrame);


			if (debug) drawFingers(globalFrame);
			drawUI(globalFrame);
		}


		window.requestAnimationFrame(update);
		//console.log(globalFrame);
	}
	function drawFingers(frame)
	{
		for (var i in frame.hands)
			for (var k in frame.hands[i].fingers)
			{
				var finger = frame.hands[i].fingers[k];
				var pos = finger.stabilizedTipPosition;

				var fx = pos[0];
				var fy = pos[1];
				var fz = pos[2];
						
						
					//draw the finger on screen
				fx = map(fx,-150,150,0,browserWidth);
				fy = map(fy,100,300,0,browserHeight);

				fy = browserHeight - fy;
				ctx.fillStyle = "#E04C4C";
				ctx.beginPath();
				ctx.arc(fx,fy,10,0,2*Math.PI);
				ctx.fill();
				ctx.closePath();
			}
			
	}
	function drawUI(frame)
	{
		//DRAW COMMON UI ELEMENTS
		var toolboxPos = getCorrectedPosition({x:100,y:810});
		var toolboxSize = getCorrectedSize({width:toolboxIMG.width,height:toolboxIMG.height});

		ctx.fillStyle = "#919191";
		ctx.drawImage(toolboxIMG,toolboxPos.x,toolboxPos.y, toolboxSize.width, toolboxSize.height);


		var stagePos = getCorrectedPosition({x:20,y:20}),
		stageSize = getCorrectedSize({width:1880, height:750});
		ctx.strokeStyle = "#000";
		ctx.strokeRect( stagePos.x,stagePos.y,stageSize.width,stageSize.height);

		var runPos = getCorrectedPosition({x:1700,y:800}),
		runSize = getCorrectedSize({width:200,height:200});

		ctx.drawImage(runBtnActive,runPos.x,runPos.y, runSize.width, runSize.height);
		//placeholder toolbar
		//ctx.strokeRect(browserWidth /10 + 100, browserHeight - 150, browserWidth/3*2, 100);

		//actual toolbar
		var buildSize = getCorrectedSize({width:buildBar.width,height:buildBar.height});
		var buildPos = getCorrectedPosition({x:400, y:800});
		ctx.drawImage(buildBar,buildPos.x,buildPos.y,buildSize.width,buildSize.height);

		//ui
		if (gameState === STATE_TOOLBOX_CLOSED)
		{
			ctx.fillStyle = "#E04C4C";
			//ctx.fillStyle = "rgba(255,255,255,0.4)"; // adds a opacity to the rect for dragging
			ctx.beginPath();
			//ctx.arc(dragCircle.x,dragCircle.y,dragCircle.radius,0,2*Math.PI);  // makes a DragCircle
			ctx.rect(toolboxPos.x,toolboxPos.y,toolboxSize.width,toolboxSize.height); // makes a rect for the toolbox opening
			ctx.fill();
			ctx.closePath();

			//draw current blocks
			for (var i in currLevel.spotsToDrag)
			{
				var s = currLevel.spotsToDrag[i];
				var b = s.slottedBlock;

				if (b != undefined)
				{
					/*ctx.fillStyle = "#000";
					ctx.fillRect(s.x-.width/2,s.y-s.height/2,s.width,s.height);*/
					ctx.drawImage(b.image,b.position.x,b.position.y,b.size.width,b.size.height);
				}
			}


			if (frame.hands[0])
			{
				var hand = frame.hands[0];
				var x = hand.palmPosition[0];
				var y = hand.palmPosition[1];
				//console.log(hand);

				var handX = map(x,-150,150,0,browserWidth);
				var handY = map(y,100,300,browserHeight,0);

				//console.log(handX+", "+handY);

				ctx.fillStyle = "#4CE083";
				ctx.beginPath();
				ctx.arc(handX,handY,20,0,2*Math.PI);
				ctx.fill();
				ctx.closePath();
				//check for placement over pullup
				var c1 = {};
				c1.x = handX;
				c1.y = handY;
				c1.radius = 20;
				if (hand.fingers.length > 0)
				{
					startDragY = -1;
					dragCircle.y = browserHeight - 100;
				}
				if (circlesIntersect(c1,dragCircle) && hand.fingers.length <= 0 && startDragY == -1)
				{
					console.log("PALM");
					startDragY = c1.y;
				}
				if (startDragY != -1)
				{
					dragCircle.y = c1.y;
					if (startDragY - c1.y > 100)
					{
						//console.log("UITHINGSHAPPEN");
						openToolbox();
					}
				}
				
			}
		}
		else if (gameState === STATE_TOOLBOX_OPEN)
		{

			ctx.globalAlpha = .75;
			ctx.fillStyle = "#000";
			ctx.fillRect(0,0,browserWidth,browserHeight);
			ctx.globalAlpha = 1;

			//draw spots to drag

			if (floatingBlocks.length == 0)
			{
				floatingBlocks = currLevel.blocks;
				//console.log("running");
			}

			for (var i in floatingBlocks)
			{
				var b = floatingBlocks[i];

				if (isCloseToDestination(b.position,b.destination))
				{
					b.isMoving = false;
				}
				else
				{
					b.isMoving = true;
				}
				if (b.isMoving && !b.isSlotted)
				{

					var idealVec = getSubtractedVector(b.position,b.destination);
					//arbitrary block speed
					idealVec = getNormalizedVector(idealVec);
					idealVec = getScaledVector(idealVec,12);

					b.position.x += idealVec.x;
					b.position.y += idealVec.y;
					
				}
				else
				{
					//perlin noise it around;

				}
				//draw it
				b.draw(globalFrame,ctx);
			}

			if (previousFrame.fingers.length == 5)
			{
				//retract blocks
				var gestureRecognized = false;
				for (var i in frame.gestures)
				{
					var g = frame.gestures[i];
					if(g.type == "swipe" && !gestureRecognized)
					{
						if (g.direction[1] < -.75)
						{
							console.log("CLOSE");
							gestureRecognized = true;
							for (var i in floatingBlocks)
							{
								var b = floatingBlocks[i];
								b.isMoving = true;
								b.destination = b.initialPosition;
								gameState = STATE_TOOLBOX_CLOSING;
							}
						}
						//console.log(g.direction[1]);
					}
				}
				//console.log(frame.gestures);
			}

						//temp array of center locations
			var spotsToDrag = currLevel.spotsToDrag;

			for (var i = spotsToDrag.length - 1; i >= 0; i--) {
				var s = spotsToDrag[i];

				ctx.strokeStyle = "#ff0000";
				ctx.lineWidth = 4;
				ctx.strokeRect(s.position.x - 50,s.position.y - 50,s.size.width,s.size.height);
			};

			//console.log(spotsToDrag);

			drag(globalFrame,spotsToDrag);
			//drawFingers(frame);
		}
		//fix this to impolemetn in the STATE_TOOLBOX OPEN
		else if (gameState == STATE_TOOLBOX_CLOSING){
			ctx.globalAlpha = .75;
			ctx.fillStyle = "#000";
			ctx.fillRect(0,0,browserWidth,browserHeight);
			ctx.globalAlpha = 1;

			console.log(currLevel.spotsToDrag);

			gameState = STATE_TOOLBOX_CLOSED;
			//drawFingers(frame);

		}
		tempHand.draw(frame,ctx);
		previousFrame = frame;
		/*pinch(frame);
		zoom(frame);*/
	}
	function drag(frame, spotsToDrag){
		if(frame.hands.length == 1)
		{
			var grab = frame.hands[0];
			//check for a fist or grab
			if(grab.fingers.length == 0)
			{
				var one_finger = true;
				//find the position of the fist
				var grab_position;
				grab_position = grab.palmPosition;

				var grab_positionX = map(grab_position[0], -150, 150,0,browserWidth);
				var grab_positionY = map(grab_position[1], 100, 300, browserHeight,0);

				for(var i in floatingBlocks)
				{
					var b = floatingBlocks[i];
					var bx = b.position.x;
					var by = b.position.y;

					if(b.isBeingDragged)
						{	
							b.position.x = grab_positionX - b.size.width/2;
							b.position.y = grab_positionY - b.size.height/2;

							//check for collision with spots to drag
							var distSub = getSubtractedVector(b.position,spotsToDrag[0]);
							var dist = getMagnitude(distSub);



								var touchingSpots = [];
								for (var k in spotsToDrag)
								{
									var s = spotsToDrag[k];

									var spotSize = s.size;
									var sPos = s.position;
									var sOrigin = {x:sPos.x-spotSize.width/2,y:sPos.y-spotSize.height/2};

									//debugger;

									if(!(b.position.y+b.size.height < sOrigin.y ||
									   b.position.y > sOrigin.y+spotSize.height ||
									   b.position.x > sOrigin.x+spotSize.width ||
									   b.position.x+b.size.width < sOrigin.x
									   ))
									{
										//debugger;
										touchingSpots.push(s);
									}

								}
								if (touchingSpots.length == 1)
								{
									var spot = touchingSpots[0];
									b.destination = {x:spot.position.x-spot.size.width/2,y:spot.position.y-spot.size.height/2};
									b.position = {x:spot.position.x-spot.size.width/2,y:spot.position.y-spot.size.height/2};
									
									spot.slottedBlock = b;
									//console.log(spot.slottedBlock);
									b.isSlotted = true;
									b.slot = spot;

									//console.log('touching spots = 1');
								}
								else
								{
									//console.log('touchingSpots = 0');
									b.destination = b.initialPosition;
									//console.log('called');
									b.isSlotted = false;
									if (b.slot) b.slot.slottedBlock = undefined;
									//console.log('called');
									b.slot = undefined;
								}
								//console.log(spotsToDrag[k].slottedBlock);
							if (dist > 400)
							{
								b.destination = b.initialPosition;
								//console.log('called');
								b.isSlotted = false;
								if (b.slot)	b.slot.slottedBlock = undefined;
								b.slot = undefined;
							}
					}
					else if(grab_positionX <= bx + 100 && grab_positionX >= bx - 100 && grab_positionY <= by + 100 && grab_positionY >= by - 100)
					{
							//console.log(b);
							var canDrag = true;
							for (var k in floatingBlocks)
							{
								var b2 = floatingBlocks[k];
								if (b2.isBeingDragged)
								{
									canDrag = false;
								}
							}
							if (canDrag)
								b.isBeingDragged  = true;
					}
						
					
				}
				
			}
			else
			{
				for(var i in floatingBlocks)
				{
					if (floatingBlocks[i].isBeingDragged)
					{
						var f = floatingBlocks[i];
						f.isBeingDragged = false;
						f.isMoving = true;
					}
				}
			}
			
		}
	}
	function isCloseToDestination(pos,dest)
	{
		//console.log(pos+ ", " + dest);

		var sub = getSubtractedVector(pos,dest);
		var mag = getMagnitude(sub);
		if (mag < 10)
		{
			return true;
		}
		else return false;
	}
	function getMagnitude(v1){
		return Math.sqrt((v1.x*v1.x)+(v1.y*v1.y));
	}
	function getNormalizedVector(v1){
		var mag = getMagnitude(v1);
		return{
			x:v1.x/mag,
			y:v1.y/mag
		};
	}
	//from v1->v2 which means v2-v1
	function getSubtractedVector(v1,v2){
		return {
			x: v2.x-v1.x,
			y: v2.y-v1.y
		};
	}
	function angleFromPointToPoint(p1,p2)
	{
		var sub = getSubtractedVector(p1,p2);

		var angle = Math.atan2(sub.y,sub.x);

		if (angle < 0){
			angle = Math.abs(angle);
			angle = Math.PI*2 - angle;
			
		}
		//angle = Math.abs(angle - Math.PI);


		return angle;
	}
	function getScaledVector(v1,scalar){
		return {
			x:v1.x*scalar,
			y:v1.y*scalar
		};
	}
	function openToolbox()
	{
		console.log(toolboxIMG);

		gameState = STATE_TOOLBOX_OPEN;
	}
	
	function setCirclePos($circ,point)
	{
		var pos = point.tipPosition;
			
		var x = pos[0];
		var y = pos[1];
		var z = pos[2];
			
			
			
		x = map(x,-150,150,0,browserWidth);
		y = map(y,100,300,0,browserHeight);
			
		//because of the inversion when dealing with screen
		y = browserHeight - y;
			
		$circ.css({
				left:x,
				top:y
			});
	}
	function setCircleWidth($circ,point)
	{
		//fix me
	
		var pos = point.tipPosition;
		var z = pos[2],oldz=z;
		
		z = map(z,-50,100,20,100);
		
		var op = map(z,20,80,.2,.8);
		
		op = 1-op;
		
		if (z <= 20) 
		{
			$circ.addClass('clicked'); 
			//console.log($circ.offset())
		}
		else $circ.removeClass('clicked');
		
		$circ.css({
				width:z,
				height:z,
				"border-radius":z,
				opacity:op
			});
	}
	function vectorToString(vector, digits) {
	  if (typeof digits === "undefined") {
		digits = 1;
	  }
	  return "(" + vector[0].toFixed(digits) + ", "
				 + vector[1].toFixed(digits) + ", "
				 + vector[2].toFixed(digits) + ")";
	}
	function map(value, start1, stop1, start2, stop2) {
		if (value < start1) value = start1;
		else if (value > stop1) value = stop1;
	
		return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));
	}
	function circlesIntersect(c1,c2){
		var dx = c2.x - c1.x;
		var dy = c2.y - c1.y;
		var distance = Math.sqrt(dx*dx + dy*dy);
		return distance < c1.radius + c2.radius;
	}
	function pointIntersectsRect(pt,rect)
	{
		return (pt.x > rect.x && pt.x < rect.x + rect.width && pt.y > rect.y && pt.y < rect.y + rect.height);
	}
	function pinch(frame){
		STATE_CAN_PINCH = false;
		if(frame.hands.length == 2)
		{
			var h1 = frame.hands[0];
			var h2 = frame.hands[1];

			if(h1.fingers.length == 1 && h2.fingers.length == 1)
			{
				STATE_CAN_PINCH = true;
				gameState = STATE_CAN_PINCH;
				var f1 = frame.fingers[0];
				var f2 = frame.fingers[1];
				f1.x = f1.tipPosition[0];
				f1.y = f1.tipPosition[1];
				f2.x = f2.tipPosition[0];
				f2.y = f2.tipPosition[1];
				var sub = getSubtractedVector(f1,f2);
				var mag = getMagnitude(sub);
				//console.log('Magnitude: '+mag);
				
				if (mag < 100)
				{
					if(currentMag-mag > 0)
					{
						//console.log('pinching');
						STATE_CAN_PINCH = false;
						STATE_PINCH = true;
						gameState = STATE_PINCH;
						currentMag = mag;
						//console.log('currentMag: '+currentMag);
						if (mag < 30)
						{
							//console.log("touching");
							STATE_PINCH = false;
						}
					}
				}
			}
		}
	}
	function zoom(frame){
		if(frame.hands.length == 2)
		{
			var h1 = frame.hands[0];
			var h2 = frame.hands[1];

			if(h1.fingers.length == 1 && h2.fingers.length == 1)
			{
				STATE_CAN_ZOOM = true;
				gameState = STATE_CAN_ZOOM;
				var f1 = frame.fingers[0];
				var f2 = frame.fingers[1];
				f1.x = f1.tipPosition[0];
				f1.y = f1.tipPosition[1];
				f2.x = f2.tipPosition[0];
				f2.y = f2.tipPosition[1];
				var sub = getSubtractedVector(f1,f2);
				var mag = getMagnitude(sub);
				
				if (mag > 30)
				{
					if(currentMag-mag < 0)
					{
						//console.log('zooming');
						STATE_CAN_ZOOM = false;
						STATE_ZOOM = true;
						gameState = STATE_ZOOM;
						currentMag = mag;
						//console.log('currentMag: '+currentMag);
						if (mag > 100)
						{
							//console.log("zoomed");
							STATE_ZOOM = false;
						}
					}
				}
				
				
			}
		}
	}
</script>
<style>
	/* http://meyerweb.com/eric/tools/css/reset/ 
	   v2.0 | 20110126
	   License: none (public domain)
	*/

	html, body, div, span, applet, object, iframe,
	h1, h2, h3, h4, h5, h6, p, blockquote, pre,
	a, abbr, acronym, address, big, cite, code,
	del, dfn, em, img, ins, kbd, q, s, samp,
	small, strike, strong, sub, sup, tt, var,
	b, u, i, center,
	dl, dt, dd, ol, ul, li,
	fieldset, form, label, legend,
	table, caption, tbody, tfoot, thead, tr, th, td,
	article, aside, canvas, details, embed, 
	figure, figcaption, footer, header, hgroup, 
	menu, nav, output, ruby, section, summary,
	time, mark, audio, video {
		margin: 0;
		padding: 0;
		border: 0;
		font-size: 100%;
		font: inherit;
		vertical-align: baseline;
	}
	/* HTML5 display-role reset for older browsers */
	article, aside, details, figcaption, figure, 
	footer, header, hgroup, menu, nav, section {
		display: block;
	}
	body {
		line-height: 1;
	}
	ol, ul {
		list-style: none;
	}
	blockquote, q {
		quotes: none;
	}
	blockquote:before, blockquote:after,
	q:before, q:after {
		content: '';
		content: none;
	}
	table {
		border-collapse: collapse;
		border-spacing: 0;
	}
	.circ
	{
		opacity:.4;
		width:20px;
		height:20px;
		border-radius:20px;
		position:absolute;
		background-color:#555;
		margin-top:-10px;
		margin-left:-10px;
		border:3px solid #111;
	}
	.circ.clicked
	{
		background-color:#A8A0EB;
		border:3px solid #A8A0EB;d
	}
</style>
</head>
<body>
	<canvas id='canvas'>GET A BROWSER</canvas>
</body>
</html>